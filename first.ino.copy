fv#include <SPI.h>
#include <TFT_eSPI.h>         // TFT-дисплей ST7796
TFT_eSPI tft = TFT_eSPI();   // Инициализация TFT-дисплея
uint32_t tft_update_timer = 0;

/*
  BDBG-09:
    * comunication protocol: bidirectional serial;
    * baud rate: 19200;
    * parity: none;
    * send bytes: 3;
    * receive bytes: 10;

  Meteo station:
    * comunication protocol: receive serial;
    * baud rate: 9600;
    * parity: none;
    * receive bytes: 17;

  Sensor box:
    * comunication protocol: RS-485 MODBUS;
    * baud rate: 19200;
    * slave device id: 2;
    * word length: 8;
    * parity: Even;
    * stop bits: 1;
    * data type: float;
    * swap bytes: enable;
    * address base: 0-based;
    * length: 8;
    * point type: 03:HOLDING REGISTER;
    * data type: float
    * start address: 20;
    * length: 6;
    * 20: CO;
    * 22: SO2;
    * 24: NO2;

  Arsenii'sTechnologies ~Proper way — The only way~   https://exch.com.ua/Bio.php
*/

//modbus master (sensor box) ->
  #include <ModbusMaster.h>
  ModbusMaster sensor_box;

  #define MASTER_DEVICE_ID 2

  float sensors_arr_decoded[5]; //array with all sensors data (+1 for safety)
  /*
    [0] -> CO
    [1] -> SO2
    [2] -> NO2
  */
  uint32_t sensor_box_request_timer; //timer variable for requesting new sensors data
//<- modbus master (sensor box)

//meteo station ->
  double meteo_arr_decoded[9]; //array with all meteo data (+1 for safety)
  /*
    [0] -> wind direction
    [1] -> temperature
    [2] -> humidity
    [3] -> wind speed
    [4] -> gust speed
    [5] -> accumulation rainfall
    [6] -> UV
    [7] -> light
    [8] -> barometric pressure
  */
  uint8_t meteo_arr[21]; //21 bytes of info from meteostation
  uint8_t meteo_arr_tmp[31]; //additional bytes for raw data to prevent memory fragmentation
  uint8_t meteo_arr_id=0;
  uint32_t meteo_arr_reset_timer;
  bool meteo_gave_new_data=false;
//<- meteo station

//BDBG-09 ->
  float radiation_level_decoded=0; //variable with current radiation level
  uint8_t radiation_arr[10]; //10 bytes of info from BDBG-09
  uint8_t radiation_arr_tmp[20]; //additional bytes for raw data to prevent memory fragmentation
  uint32_t radiation_request_timer;
  uint8_t radiation_arr_id=0;
  uint32_t radiation_arr_reset_timer;
  bool radiation_gave_new_data=false;
//<- BDBG-09


unsigned long lastPostTime = 0;
const unsigned long postInterval = 5000; // 5 секунд


//Ethernet MODBUS ->
  #include <Ethernet.h>

  #define ENC28J60_CS 10
  EthernetServer server(502);
  byte mac[]={0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED};

  const int send_arr_size=30;
  double send_arr[send_arr_size+1]; //array will all the data to send via ethernet modbus (+1 for safety)
  const float default_send_arr_val=-1;

  uint32_t send_arr_update_timer;
//<- Ethernet MODBUS

void setup() 
{
  
  tft.init();
  tft.setRotation(1);
  tft.fillScreen(TFT_BLACK);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.setTextSize(2);
  // byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };
  // if (Ethernet.begin(mac) == 0) {
  //   Serial.println("DHCP не удался");
  //   while (true); // остановка при ошибке DHCP
  // }
  Serial.print("IP адрес: ");
  Serial.println(Ethernet.localIP());

  Serial.begin(115200);
  Serial1.begin(9600);
  Serial2.begin(19200);
  Serial3.begin(9600, SERIAL_8E1);

  Serial.setTimeout(10);
  Serial1.setTimeout(10);
  Serial2.setTimeout(10);
  // Serial3.setTimeout(10);

  sensor_box.begin(MASTER_DEVICE_ID, Serial3);
  sensor_box.preTransmission(pre_transmission_main);
  sensor_box.postTransmission(post_transmission_main);

  pinMode(4, OUTPUT);
  pinMode(5, OUTPUT);

  for(int id=0; id<send_arr_size; id++)
  {
    send_arr[id]=default_send_arr_val;
  }
  send_arr[0] = 5.10;
  send_arr[1] = 3.01;
  send_arr[2] = 0.13;
  send_arr[3] = 20;
  send_arr[4] = 22.6;
  send_arr[5] = 56;
  send_arr[6] = 4.76;
  send_arr[7] = 5.6;
  send_arr[8] = 28;
  send_arr[9] = 3;
  send_arr[10] = 540;
  send_arr[11] = 1010.22;
  send_arr[12] = 9;
  send_arr[13] = 1.1;


  Serial.println("start - Arsenii'sTechnologies");
  delay(100);

  Ethernet.init(ENC28J60_CS);
  if (Ethernet.begin(mac) == 0) {
      // Якщо не вдалося — використовуємо ручну адресу
      Serial.println("DHCP не вдалося. Встановлюємо статичну адресу.");
      IPAddress ip(192, 168, 0, 101);
      IPAddress myDns(192, 168, 0, 1); // DNS роутера, якщо треба
      Ethernet.begin(mac, ip, myDns);
  }
  server.begin();
  Serial.print("Modbus server on ");
  Serial.println(Ethernet.localIP());
}

void loop() 
{
  // if (millis() - lastPostTime >= postInterval) {
  //   Serial.println("POST POST POST 5 sec");
  //   lastPostTime = millis();
  //   sendPostRequest();
  // }

  if (millis() - tft_update_timer > 3000) {
    tft_update_timer = millis();
    drawData();
  }

//Meteo-------------------------------------->
  if(Serial1.available() && 1==1)
  {
    uint8_t read_byte_tmp;
    read_byte_tmp=Serial1.read();
    Serial.print(read_byte_tmp, HEX);
    Serial.print(' ');

    meteo_arr_tmp[meteo_arr_id]=read_byte_tmp;
    if(meteo_arr_id<30) meteo_arr_id++;

    meteo_gave_new_data=true;
    meteo_arr_reset_timer=millis();
  }

  if(millis()-meteo_arr_reset_timer>=500 && meteo_gave_new_data)
  {
    Serial.println();
    meteo_arr_reset_timer=millis();
    meteo_gave_new_data=false;

    if(meteo_arr_id==17)
    {
      Serial.println("data is valid. moving to real array");
      for(uint8_t id=0; id<21; id++)
      {
        meteo_arr[id]=meteo_arr_tmp[id];
      }

      //wind direction
      uint16_t wind_dir_raw=((meteo_arr[3] >> 4) << 8) | meteo_arr[2];
      //Serial.print("meteo_arr[2]=");
      //Serial.println(meteo_arr[2], HEX);
      //Serial.print("meteo_arr[3]=");
      //Serial.println(meteo_arr[3] >> 4, HEX);
      meteo_arr_decoded[0]=(uint8_t)wind_dir_raw;

      // Temperature
      int16_t temp_raw=((meteo_arr[3] & 0x0F) << 8) | meteo_arr[4];
      //Serial.print("temp_raw=");
      //Serial.println(temp_raw, HEX);
      //Serial.print("meteo_arr[3]=");
      //Serial.println(meteo_arr[3], HEX);
      //Serial.print("meteo_arr[4]=");
      //Serial.println(meteo_arr[4], HEX);
      meteo_arr_decoded[1]=(temp_raw - 400)/10.0;

      //humidity
      meteo_arr_decoded[2]=meteo_arr[5];

      //wind speed
      uint16_t wind_speed_raw=meteo_arr[6];
      //Serial.print("meteo_arr[6]=");
      //Serial.println(meteo_arr[6], HEX);
      meteo_arr_decoded[3]=((float)wind_speed_raw/8)*1.12;

      //gust speed
      meteo_arr_decoded[4]=meteo_arr[7]*1.12;

      //rainfall
      meteo_arr_decoded[5]=((meteo_arr[8] & 0x0F) << 8) | meteo_arr[9];

      //UV
      meteo_arr_decoded[6]=((meteo_arr[10] & 0x0F) << 8) | meteo_arr[11];

      //light
      uint64_t light=((uint64_t)meteo_arr[12] << 16) | ((uint64_t)meteo_arr[13] << 8) | ((uint64_t)meteo_arr[14]);
      meteo_arr_decoded[7]=light/10.0;

      //pressure
      uint64_t pressure_raw=((uint64_t)meteo_arr[17] << 16) | ((uint64_t)meteo_arr[18] << 8) | ((uint64_t)meteo_arr[19]);
      meteo_arr_decoded[8]=(double)pressure_raw/100;

      //output
      Serial.print("Wind direction: "); Serial.print(meteo_arr_decoded[0]); Serial.println("°");
      Serial.print("Temperature: "); Serial.print(meteo_arr_decoded[1]); Serial.println("°C");
      Serial.print("Humidity: "); Serial.print(meteo_arr_decoded[2]); Serial.println("%");
      Serial.print("Wind speed: "); Serial.print(meteo_arr_decoded[3]); Serial.println("m/s");
      Serial.print("Gust speed: "); Serial.print(meteo_arr_decoded[4]); Serial.println("m/s");
      Serial.print("Rainfall: "); Serial.print(meteo_arr_decoded[5]); Serial.println("mm");
      Serial.print("UV: "); Serial.print(meteo_arr_decoded[6]); Serial.println("uW/cm^2");
      Serial.print("Light: "); Serial.print(meteo_arr_decoded[7]); Serial.println("lux");
      Serial.print("Pressure: "); Serial.print(meteo_arr_decoded[8]); Serial.println("hPa");
    }
    else 
    {
      Serial.print("bytes count=");
      Serial.print(meteo_arr_id);
      Serial.println("  ~Bad data. Displaying old values!");
    }
    meteo_arr_id=0;

    for(uint8_t id=0; id<21; id++)
    {
      Serial.print(meteo_arr[id], HEX);
      Serial.print(' ');
    }
    Serial.println();
    Serial.println();
    Serial.println();
  }
// <--------------------------------------Meteo

// BDBG-09-------------------------------------->
  if(millis()-radiation_request_timer>=5000 && 1==1)
  {
    radiation_request_timer=millis();

    digitalWrite(4, 1);
    while(Serial2.available()) Serial2.read();

    uint8_t cmd[] = {0x55, 0xAA, 0x01};
    Serial2.write(cmd, sizeof(cmd));
    Serial2.flush();
    
    digitalWrite(4, 0);
    Serial.println("sent");
  }
  if(Serial2.available())
  {
    uint8_t received_byte_radiation=Serial2.read();
    radiation_arr_tmp[radiation_arr_id]=received_byte_radiation;
    if(radiation_arr_id<19) radiation_arr_id++;
    Serial.print(received_byte_radiation, HEX);
    Serial.print(' ');

    radiation_gave_new_data=true;
    radiation_arr_reset_timer=millis();
  }
  if(millis()-radiation_arr_reset_timer>=500 && radiation_gave_new_data)
  {
    radiation_arr_reset_timer=millis();
    radiation_gave_new_data=false;
    if(radiation_arr_id==10)
    {
      Serial.println("data is valid. moving to real array");
      for(uint8_t id=0; id<10; id++)
      {
        radiation_arr[id]=radiation_arr_tmp[id];

        uint32_t radiation_raw=((uint32_t)radiation_arr[6] << 24) |
                               ((uint32_t)radiation_arr[5] << 16) |
                               ((uint32_t)radiation_arr[4] << 8)  |
                               ((uint32_t)radiation_arr[3]);

        radiation_level_decoded=radiation_raw/100.0;
      }
    }
    else 
    {
      Serial.print("bytes count=");
      Serial.print(radiation_arr_id);
      Serial.println("  ~Bad data. Displaying old values!");
    }
    radiation_arr_id=0;

    Serial.println();
    for(uint8_t id=0; id<10; id++)
    {
      Serial.print(radiation_arr[id], HEX);
      Serial.print(' ');
    }
    Serial.println();

    Serial.print("Radiation: ");
    Serial.print(radiation_level_decoded, 2);
    Serial.println("uSv/h");
    Serial.println();
    Serial.println();
  }
// <--------------------------------------BDBG-09

//Sensor box-------------------------------------->
  if(millis()-sensor_box_request_timer>=1000 && 1==1)
  {
    sensor_box_request_timer=millis();

    uint8_t result=sensor_box.readHoldingRegisters(20, 6);

    if (result==sensor_box.ku8MBSuccess)
    {
      for (uint8_t id=0; id<6; id+=2)
      {
        uint8_t array_id=id/2;

        uint16_t high_word=sensor_box.getResponseBuffer(id);
        uint16_t low_word=sensor_box.getResponseBuffer(id+1);

        uint32_t raw_value=((uint32_t)low_word << 16) | high_word;

        float sensor_value;
        memcpy(&sensor_value, &raw_value, sizeof(float));

        sensors_arr_decoded[array_id]=sensor_value;
      }

      Serial.print(sensors_arr_decoded[0], 4);
      Serial.print("\t");
      Serial.print(sensors_arr_decoded[1], 4);
      Serial.print("\t");
      Serial.println(sensors_arr_decoded[2], 4);
    }
    else
    {
      Serial.print("Error: ");
      Serial.println(result, HEX);
      post_transmission_main();
    }
  }
//<--------------------------------------Sensor box



//send_arr processing-------------------------------------->
  if(millis()-send_arr_update_timer>=2000)
  {
    send_arr_update_timer=millis();
    /*
      [0] -> CO
      [1] -> SO2
      [2] -> NO2
      [3] -> wind direction
      [4] -> temperature
      [5] -> humidity
      [6] -> wind speed
      [7] -> gust speed
      [8] -> accumulation rainfall
      [9] -> UV
      [10] -> light
      [11] -> barometric pressure
      [12] -> radiation
      [13] -> internal temp
    */


    // uint8_t id=0;
    // send_arr[id]=sensors_arr_decoded[id];
    // id++;
    // send_arr[id]=sensors_arr_decoded[id];
    // id++;
    // send_arr[id]=sensors_arr_decoded[id];
    // id++;
    // uint8_t curr_id=id;
    // for(id=curr_id; id<=curr_id+8; id++)
    // {
    //   send_arr[id]=meteo_arr_decoded[id-3];
    // }
    // send_arr[12]=radiation_level_decoded;
    // send_arr[13]=22.5;


    for(int id=0; id<=13; id++) //print array
    {
      Serial.print("send_arr");
      Serial.print('[');
      Serial.print(id);
      Serial.print("]=");
      Serial.print(send_arr[id]);
      Serial.println(';');
    }
  }
//<--------------------------------------send_arr processing


//Ethernet MODBUS-------------------------------------->
  EthernetClient client=server.available();
  if (!client || !client.connected()) return;

  if (client.available()>=12) 
  {
    // char buf[50];
    byte request[12];
    client.read(request, 12);

    for(int i = 0; i < 12; i++){
      // sprintf(buf, "index %d: %.2f", i, request[i]); 
      Serial.print("Index ");
      Serial.print(i);
      Serial.print(": ");
      Serial.println(request[i], HEX);
    }
    Serial.println();

    uint8_t unit_id=request[6];
    uint8_t func=request[7];
    uint16_t addr=(request[8] << 8) | request[9];
    uint16_t count=(request[10] << 8) | request[11];

    Serial.print("Req FC: "); Serial.print(func);
    Serial.print(" Addr: "); Serial.print(addr);
    Serial.print(" Count: "); Serial.println(count);

    uint16_t total_regs=send_arr_size*2;

    if (func==3 && addr+count<=total_regs) 
    {
      byte response[260];
      uint16_t byte_count=count*2;

      uint16_t len=3+byte_count;

      response[0]=request[0];
      response[1]=request[1];
      response[2]=0;
      response[3]=0;
      response[4]=highByte(len);
      response[5]=lowByte(len);
      response[6]=unit_id;
      response[7]=func;
      response[8]=byte_count;

      for (uint16_t i=0; i<count; i++) 
      {
        uint16_t reg_index=addr+i;
        uint8_t float_index=reg_index/2;
        uint8_t part=reg_index%2;

        double val=send_arr[float_index];
        uint32_t fbits=*((uint32_t*)&val);

        if (part==0) 
        {
          response[9+i*2]=(fbits >> 24) & 0xFF; // A
          response[10+i*2]=(fbits >> 16) & 0xFF; // B
          Serial.print("Big-endian: ");
          Serial.print((fbits >> 24) & 0xFF, HEX); Serial.print(" ");
          Serial.print((fbits >> 16) & 0xFF, HEX); Serial.println();
          // Serial.print((fbits >> 8) & 0xFF, HEX);  Serial.print(" ");
          // Serial.print(fbits & 0xFF, HEX);         Serial.println();
        } 
        else
        {

          response[9+i*2]=(fbits >> 8) & 0xFF; // C
          response[10+i*2]=fbits & 0xFF; // D
          Serial.print("Little-endian: ");
          Serial.print(fbits & 0xFF, HEX);         Serial.print(" ");
          Serial.print((fbits >> 8) & 0xFF, HEX);  Serial.println();
          // Serial.print((fbits >> 16) & 0xFF, HEX); Serial.print(" ");
          // Serial.print((fbits >> 24) & 0xFF, HEX); Serial.println();
        }

      
      //  for(int i=0; i < count; i++){
      //     Serial.println("Array send_arr");
      //     Serial.print("Index ");
      //     Serial.print(i);
      //     Serial.print(": ");
      //     Serial.println(response[i], HEX);
      }

      Serial.println("=== RESPONSE (HEX) ===");
      for (int i = 0; i < (9 + byte_count); i++) {
          if (response[i] < 0x10) Serial.print("0"); // для краси, leading zero
          Serial.print(response[i], HEX);
          Serial.print(" ");
          // можна ще додати ASCII чи index для дебагу:
          // Serial.print(" ["); Serial.print(i); Serial.print("]");
      }
      Serial.println();
      Serial.println("=====================");


      client.write(response, 9+byte_count);
    } 
    else 
    {
      byte err[]=
      {
        request[0], request[1], 0, 0, 0, 3, unit_id, func | 0x80, 0x02
      };
      client.write(err, 9);
    }

    client.flush();
    //delay(10);
    //client.stop();
  }
//<--------------------------------------Ethernet MODBUS

  
}





void pre_transmission_main()
{
  digitalWrite(5, HIGH);
}

void post_transmission_main()
{
  digitalWrite(5, LOW);
}

void sendPostRequest() {
  EthernetClient postClient;
  IPAddress server(192, 168, 0, 104); // IP твого MacBook або Flask сервера
  const int port = 4000;

  Serial.println("Sent POST request");
  Serial.print("IP: "); Serial.println("192.168.0.101");
  Serial.print("PORT: "); Serial.println(port);

  if (postClient.connect(server, port)) {
    String postData = "{\"message\": \"Hello from Postman!\", \"value\": 42}";

    // Формуємо HTTP POST
    postClient.println("POST /post_endpoint HTTP/1.1");
    postClient.println("Host: 192.168.0.104");
    postClient.println("Content-Type: application/json");
    postClient.print("Content-Length: ");
    postClient.println(postData.length());
    postClient.println();
    postClient.print(postData);

    // Дочекаємось відповіді (не обов'язково)
    unsigned long timeout = millis();
    while (postClient.connected() && millis() - timeout < 500) {
      while (postClient.available()) {
        char c = postClient.read();
        Serial.write(c);
      }
    }
    postClient.stop();
    Serial.println("POST sent");
  } else {
    Serial.println("POST connection failed");
  }
}

void drawData() {
  static float prev_send_arr[31];

  int col1_x = 0;
  int col2_x = 160; // середина 320x экран
  int y_step = 20;

  for (int i = 0; i < 31; i++) {
    if (send_arr[i] != prev_send_arr[i]) {
      int x = (i < 16) ? col1_x : col2_x;
      int y = (i < 16) ? i * y_step : (i - 16) * y_step;

      // Очистка предыдущего текста
      tft.fillRect(x, y, 150, y_step, TFT_BLACK);

      char label[16];
      sprintf(label, "CH%02d: ", i + 1);
      tft.setCursor(x, y);
      tft.print(label);

      if (send_arr[i] == -1) {
        tft.print("#.##");
      } else {
        tft.print(send_arr[i], 2);
      }

      prev_send_arr[i] = send_arr[i];
    }
  }
}
